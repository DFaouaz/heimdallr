


#include "ClassFinder.h"
#include <clang/Tooling/Tooling.h>
#include "clang/AST/Decl.h"
#include <filesystem>
#include <regex>



ClassFinder::ClassFinder() :
	m_Context(nullptr),
	m_SourceManager(nullptr),
	m_FileName(),
	m_Classes()
{
}

void ClassFinder::run(const clang::ast_matchers::MatchFinder::MatchResult& result)
{
	m_Context = result.Context;
	m_SourceManager = result.SourceManager;

	clang::EnumDecl const* enumDecl = result.Nodes.getNodeAs<clang::EnumDecl>("id");
	if (enumDecl != nullptr)
	{
		clang::EnumDecl const* enumDeclTmp = clang::dyn_cast<clang::EnumDecl>(enumDecl->getNextDeclInContext());
		if (enumDeclTmp == nullptr) return;

		clang::EnumDecl* nEnumDecl = const_cast<clang::EnumDecl*>(enumDeclTmp);
		nEnumDecl->setAttrs(enumDecl->getAttrs());
		return FoundEnum(nEnumDecl);
	}

	clang::CXXRecordDecl const* record = result.Nodes.getNodeAs<clang::CXXRecordDecl>("id");
	if (record != nullptr && record->getNextDeclInContext() != nullptr)
	{
		clang::CXXRecordDecl const* recordDeclTmp = clang::dyn_cast<clang::CXXRecordDecl>(record->getNextDeclInContext());
		if (recordDeclTmp == nullptr || !recordDeclTmp->hasDefinition()) return;

		clang::CXXRecordDecl* recordDecl = const_cast<clang::CXXRecordDecl*>(recordDeclTmp);
		recordDecl->setAttrs(record->getAttrs());
		return FoundRecord(recordDecl);
	}

	clang::FieldDecl const* field = result.Nodes.getNodeAs<clang::FieldDecl>("id");
	if (field != nullptr)
	{
		return FoundField(field);
	}

	clang::FunctionDecl const* function = result.Nodes.getNodeAs<clang::FunctionDecl>("id");
	if (function != nullptr)
	{
		return FoundFunction(function);
	}

}

void ClassFinder::onStartOfTranslationUnit()
{
}

void ClassFinder::onEndOfTranslationUnit()
{
	/* For stdout output. */
	/* raw_fd_ostream os(1, false); */
	std::error_code ec;
	std::string headerFileName = m_FileName;
	headerFileName.append(".heimdallr_generated.h");

	std::string cppFileName = m_FileName;
	cppFileName.append(".heimdallr_generated.cpp");

	llvm::raw_fd_ostream osh(headerFileName, ec);
	llvm::raw_fd_ostream oscpp(cppFileName, ec);

	assert(!ec && "error opening file");

	for (ReflectedClass& ref : m_Classes)
	{
		ref.Generate(m_Context, osh);
	}

	for (ReflectedEnum& ref : m_Enums)
	{
		ref.Generate(m_Context, osh);
	}

	oscpp << "#include \"" << headerFileName << "\"\n";
}

void ClassFinder::FoundEnum(const clang::EnumDecl* enumDecl)
{
	//enumDecl->dump();
	m_FileName = m_SourceManager->getFilename(enumDecl->getLocation());

	// at this point m_FileName has no extension (TODO: this is the absolute path)
	m_Enums.emplace_back(ReflectedEnum(m_FileName.c_str(), enumDecl));

	std::filesystem::path path = m_FileName;
	path.replace_extension();
	m_FileName = path.string(); // strip out the ".cpp/.h/.hpp"
}

void ClassFinder::FoundRecord(const clang::CXXRecordDecl* record)
{
	//record->dump();
	m_FileName = m_SourceManager->getFilename(record->getLocation());

	// at this point m_FileName has no extension (TODO: this is the absolute path)
	m_Classes.emplace_back(ReflectedClass(m_FileName.c_str(), record));

	std::filesystem::path path = m_FileName;
	path.replace_extension();
	m_FileName = path.string(); // strip out the ".cpp/.h/.hpp"
}

void ClassFinder::FoundField(const clang::FieldDecl* field)
{
	// check if this field belongs to the current class
	if (m_Classes.size() > 0 && m_Classes.back().m_Record == field->getParent())
	{
		m_Classes.back().AddField(field);
	}
	else
	{
		printf("WARNING: Field \"%s\" ignored because its container \"%s\" it's not reflected\n", field->getQualifiedNameAsString().c_str(), field->getParent()->getNameAsString().c_str());
	}
}

void ClassFinder::FoundFunction(const clang::FunctionDecl* function)
{
	// check if this field belongs to the current class
	if (m_Classes.size() > 0 && m_Classes.back().m_Record == function->getParent())
	{
		m_Classes.back().AddFunction(function);
	}
	else
	{
		printf("WARNING: Function \"%s\" ignored because its container \"%s\" it's not reflected\n", function->getQualifiedNameAsString().c_str(), clang::dyn_cast<clang::CXXRecordDecl>(function->getParent())->getNameAsString().c_str());
	}
}

void ReflectedClass::Generate(clang::ASTContext* ctx, llvm::raw_ostream& os)
{
	std::string prefix = Utils::GetFullScopeNamePrefix(m_Record->getParent(), true, "_");
	std::string typeName = m_Record->getName().str();

	os << "// -------------------------------------------------------" << "\n";
	os << "// This code was auto-generated by Heimdallr. DO NOT EDIT!" << "\n";
	os << "// -------------------------------------------------------" << "\n";
	os << "\n";
	os << "#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__" << "\n";
	{
		os << "#pragma once" << "\n";
		os << "#ifndef _HEIMDALLR_" << prefix << typeName << "_REFLECTED_GENERATED_" << "\n";
		os << "#define _HEIMDALLR_" << prefix << typeName << "_REFLECTED_GENERATED_" << "\n";
		{
			os << "\n";
			os << "#include \"heimdallr.h\"" << "\n";
			os << "#include \"" << m_FileName << "\"" << "\n";
			os << "\n";
			os << "#define CLASS_TYPE " << Utils::GetFullScopeNamePrefix(m_Record->getParent()) << typeName << "\n";
			os << "#define CLASS_PARENT_CLASSES_COUNT " << std::to_string(std::distance(m_Record->bases_begin(), m_Record->bases_end())) << "\n";
			os << "#define CLASS_PROPERTIES_COUNT " << std::to_string(m_Fields.size()) << "\n";
			os << "#define CLASS_FUNCTIONS_COUNT " << std::to_string(m_Functions.size()) << "\n";
			os << "#define CLASS_TEMPLATED_ARGS_COUNT " << std::to_string(0) << "\n";
			os << "\n";
			os << "namespace hmdl" << "\n";
			os << "{" << "\n";
			{
				for (int i = 0; i < m_Functions.size(); ++i)
				{
					GenerateFunction(ctx, os, i);
				}

				GenerateClass(ctx, os);
			}

			os << "} // namespace hmdl" << "\n";
			for (int i = 0; i < m_Functions.size(); ++i)
			{
				os << "#undef FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << "\n";
			}

			os << "#undef CLASS_TYPE" << "\n";
			os << "#undef CLASS_PARENT_CLASSES_COUNT" << "\n";
			os << "#undef CLASS_PROPERTIES_COUNT" << "\n";
			os << "#undef CLASS_FUNCTIONS_COUNT" << "\n";
			os << "#undef CLASS_TEMPLATED_ARGS_COUNT" << "\n";
		}
		os << "#endif" << "\n";
	}
	os << "#endif" << "\n";

}

void ReflectedClass::GenerateClass(clang::ASTContext* ctx, llvm::raw_ostream& os)
{
	std::string prefix = Utils::GetFullScopeNamePrefix(m_Record->getParent(), true, "_");
	std::string typeName = m_Record->getName().str();

	os << "#define CLASS_STORAGE_VARIABLE " << prefix << typeName << "_Heimdallr_ClassStorage" << "\n";
	os << "#define CLASS_STORAGE_ARGS CLASS_TYPE, CLASS_PARENT_CLASSES_COUNT, CLASS_PROPERTIES_COUNT, CLASS_FUNCTIONS_COUNT, CLASS_TEMPLATED_ARGS_COUNT" << "\n";
	os << "\n";

	os << "namespace __internal__" << "\n";
	os << "{" << "\n";
	{ // __internal__ namespace
		os << "namespace // anonymous namespace" << "\n";
		os << "{" << "\n";
		{
			os << "inline ClassStorage<CLASS_STORAGE_ARGS> CLASS_STORAGE_VARIABLE(" << "\n";
			os << "[](ClassStorage<CLASS_STORAGE_ARGS>* self)" << "\n";
			os << "{" << "\n";
			{
				GenerateClassStorageBody(ctx, os);
			}
			os << "}" << "\n";
			os << ");" << "\n";
			os << "\n";
			os << "#define CLASS_DEFAULT_VALUE_VARIABLE " << prefix << typeName << "_Heimdallr_Class_DefaultValue" << "\n";
			os << "#define CLASS_INFO_VARIABLE " << prefix << typeName << "_Heimdallr_ClassInfo" << "\n";
			os << "#define CLASS_INFO_REGISTER_VARIABLE " << prefix << typeName << "_Heimdallr_ClassInfo_Register" << "\n";
			os << (m_Record->hasDefaultConstructor() ? "inline CLASS_TYPE CLASS_DEFAULT_VALUE_VARIABLE = {};" : "") << "\n";
			os << "inline ClassInfo CLASS_INFO_VARIABLE" << "\n";
			os << "{" << "\n";
			os << "TypeInfo::InvalidID," << "\n";
			os << "\"" << typeName << "\"," << "\n";
			os << "\"" << Utils::GetFullScopeNamePrefix(m_Record->getParent()) << typeName << "\"," << "\n";
			os << "sizeof(CLASS_TYPE)," << "\n";
			os << "alignof(CLASS_TYPE)," << "\n";
			os << (m_Record->hasDefaultConstructor() ? "&CLASS_DEFAULT_VALUE_VARIABLE," : "nullptr,") << "\n";
			os << "CLASS_STORAGE_VARIABLE.m_ParentClasses.data()," << "\n";
			os << "CLASS_STORAGE_VARIABLE.ParentClassesCount," << "\n";
			os << "CLASS_STORAGE_VARIABLE.m_Fields.data()," << "\n";
			os << "CLASS_STORAGE_VARIABLE.FieldsCount," << "\n";
			os << "CLASS_STORAGE_VARIABLE.m_Functions.data()," << "\n";
			os << "CLASS_STORAGE_VARIABLE.FunctionsCount," << "\n";
			os << "CLASS_STORAGE_VARIABLE.m_Attributes" << "\n";
			os << "};" << "\n";
			os << "\n";
			os << "inline hmdl::__internal__::registry::RegisterHelper CLASS_INFO_REGISTER_VARIABLE(&CLASS_INFO_VARIABLE);" << "\n";
		}
		os << "} // anonymous namespace" << "\n";

		os << "template<> const TypeInfo* GetTypeImpl(TemplatedTag<CLASS_TYPE>) noexcept" << "\n";
		os << "{" << "\n";
		os << "return GetClass<CLASS_TYPE>();" << "\n";
		os << "}" << "\n";
		os << "\n";
		os << "template<> const ClassInfo* GetClassImpl(TemplatedTag<CLASS_TYPE>) noexcept" << "\n";
		os << "{" << "\n";
		os << "return &CLASS_INFO_VARIABLE;" << "\n";
		os << "}" << "\n";
		os << "\n";
	}
	os << "} // __internal__" << "\n";

	os << "#undef CLASS_DEFAULT_VALUE_VARIABLE" << "\n";
	os << "#undef CLASS_STORAGE_VARIABLE" << "\n";
	os << "#undef CLASS_STORAGE_ARGS" << "\n";
	os << "#undef CLASS_INFO_VARIABLE" << "\n";
	os << "#undef CLASS_INFO_REGISTER_VARIABLE" << "\n";

}

void ReflectedClass::GenerateClassStorageBody(clang::ASTContext* ctx, llvm::raw_ostream& os)
{
	os << "// begin parent classes metadata" << "\n";
	{
		size_t index = 0;
		for (const auto& baseClass : m_Record->bases())
		{
			os << "self->m_ParentClasses[" << std::to_string(index) << "] = GetClass<" << baseClass.getType().getAsString(m_PrintingPolicy) << ">();" << "\n";
			++index;
		}
	}
	os << "// end parent classes metadata" << "\n";

	for (int i = 0; i < m_Fields.size(); ++i)
	{
		const clang::FieldDecl* fieldDecl = m_Fields[i];
		std::string fieldType = GetDesugaredType(ctx, fieldDecl->getType()).getAsString(m_PrintingPolicy);
		fieldType = Utils::RemoveAnonymousTag(fieldType);
		os << "// property \"" << fieldDecl->getType().getAsString(m_PrintingPolicy) << " " << fieldDecl->getName().str() << "\"" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetType(GetType<" << fieldType << ">());" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetOwnerType(GetType<CLASS_TYPE>());" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetName(\"" << fieldDecl->getName().str() << "\");" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetOffset(" << std::to_string(fieldDecl->getASTContext().getFieldOffset(fieldDecl) / 8) << ");" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetAccessSpecifier(" << GetAccessSpecifierString(fieldDecl) << ");" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetQualifiers(" << GetQualifiersString(fieldDecl) << ");" << "\n";
		os << "self->m_Fields[" << std::to_string(i) << "].SetTypeSpecialization(" << GetTypeSpecializationString(fieldDecl) << ");" << "\n";

		if (const clang::ConstantArrayType* arrayType = clang::dyn_cast<clang::ConstantArrayType>(fieldDecl->getType()))
		{
			uint64_t lenght = *(arrayType->getSize().getRawData());
			os << "self->m_Fields[" << std::to_string(i) << "].SetArraySize(" + std::to_string(lenght) + ");" << "\n";
		}
		else
		{
			os << "self->m_Fields[" << std::to_string(i) << "].SetArraySize(0);" << "\n";
		}
		{	// attributes
			int index = 0;
			std::vector<std::string> attrs = Utils::GetAttributesList(fieldDecl);
			std::unordered_map<std::string, size_t> attrNameToCount;
			for (const std::string& attr : attrs)
			{
				auto pair = Utils::GetParsedAttribute(attr);
				std::string attrType = pair.first;
				std::string attrArgs = pair.second;
				std::string attrName = fieldDecl->getName().str() + "_field" + std::to_string(i) + "_attr" + std::to_string(index);
				os << "static " << attrType << " " << attrName << " = { " << attrArgs << " };" << "\n";
				os << "self->m_Fields[" << std::to_string(i) << "].m_Attributes.push_back(&" << attrName << ");" << "\n";
				++index;

				if (attrNameToCount.find(attrType) == attrNameToCount.end())
				{
					attrNameToCount[attrType] = 0;
				}
				++attrNameToCount[attrType];
			}

			// assertion
			for (auto attr : attrNameToCount)
			{
				os << "static_assert(" << attr.first << "::CanAllowMultiple() || " << std::to_string(attr.second) << " == 1, \"Cannot have multiple attributes of type " << attr.first << "\");" << "\n";
			}
		}
		os << "\n";
	}

	for (int i = 0; i < m_Functions.size(); ++i)
	{
		os << "self->m_Functions[" << std::to_string(i) << "].SetName(FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << ".m_Name);" << "\n";
		os << "self->m_Functions[" << std::to_string(i) << "].SetReturnType(FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << ".m_ReturnType);" << "\n";
		os << "self->m_Functions[" << std::to_string(i) << "].SetParameters(FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << ".m_Parameters.data(), " << "FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << ".m_Parameters.size());" << "\n";
		os << "self->m_Functions[" << std::to_string(i) << "].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE" << std::to_string(i) << ".m_InvokeFunc);" << "\n";

		{	// attributes
			int index = 0;
			std::vector<std::string> attrs = Utils::GetAttributesList(m_Functions[i]);
			std::unordered_map<std::string, size_t> attrNameToCount;
			for (const std::string& attr : attrs)
			{
				auto pair = Utils::GetParsedAttribute(attr);
				std::string attrType = pair.first;
				std::string attrArgs = pair.second;
				std::string attrName = m_Functions[i]->getName().str() + "_func" + std::to_string(i) + "_attr" + std::to_string(index);
				os << "static " << attrType << " " << attrName << " = { " << attrArgs << " };" << "\n";
				os << "self->m_Functions[" << std::to_string(i) << "].m_Attributes.push_back(&" << attrName << ");" << "\n";
				++index;

				if (attrNameToCount.find(attrType) == attrNameToCount.end())
				{
					attrNameToCount[attrType] = 0;
				}
				++attrNameToCount[attrType];
			}

			// assertion
			for (auto attr : attrNameToCount)
			{
				os << "static_assert(" << attr.first << "::CanAllowMultiple() || " << std::to_string(attr.second) << " == 1, \"Cannot have multiple attributes of type " << attr.first << "\");" << "\n";
			}

		}
	}

	{	// class attributes
		int index = 0;
		std::vector<std::string> attrs = Utils::GetAttributesList(m_Record);
		std::unordered_map<std::string, size_t> attrNameToCount;
		for (const std::string& attr : attrs)
		{
			auto pair = Utils::GetParsedAttribute(attr);
			std::string attrType = pair.first;
			std::string attrArgs = pair.second;
			std::string attrName = m_Record->getName().str() + "_class" + "_attr" + std::to_string(index);
			os << "static " << attrType << " " << attrName << " = { " << attrArgs << " };" << "\n";
			os << "self->m_Attributes.push_back(&" << attrName << ");" << "\n";
			++index;

			if (attrNameToCount.find(attrType) == attrNameToCount.end())
			{
				attrNameToCount[attrType] = 0;
			}
			++attrNameToCount[attrType];
		}

		// assertion
		for (auto attr : attrNameToCount)
		{
			os << "static_assert(" << attr.first << "::CanAllowMultiple() || " << std::to_string(attr.second) << " == 1, \"Cannot have multiple attributes of type " << attr.first << "\");" << "\n";
		}
	}

}

void ReflectedClass::GenerateFunction(clang::ASTContext* ctx, llvm::raw_ostream& os, int index)
{
	std::string prefix = Utils::GetFullScopeNamePrefix(m_Record->getParent(), true, "_");
	std::string typeName = m_Record->getName().str();

	os << "#define FUNCTION_STORAGE_VARIABLE" << std::to_string(index) << " " << prefix << typeName << "_" << m_Functions[index]->getName() << std::to_string(index) << "_Heimdallr_FunctionStorage" << "\n";
	os << "#define FUNCTION_STORAGE_ARGS " << GetFunctionStorageTemplateParamsString(index) << "\n";
	os << "#define FUNCTION_NAME " << m_Functions[index]->getName() << "\n";
	os << "#define FUNCTION_SIGNATURE " << GetFunctionSignatureString(index) << "\n";
	os << "#define FUNCTION_PTR_SIGNATURE " << GetFunctionPtrSignatureString(index) << "\n";
	os << "#define FUNCTION_INDEX " << std::to_string(index) << "\n";
	os << "#define FUNCTION_INVOKER " << prefix << typeName << "_" << m_Functions[index]->getName() << std::to_string(index) << "_Heimdallr_FunctionInvoker" << "\n";
	os << "#define FUNCTION_LAMBDA_SIGNATURE " << GetFunctionLambdaSignatureString(index) << "\n";
	{
		os << "namespace __internal__" << "\n";
		os << "{" << "\n";

		os << "template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>" << "\n";
		os << "{" << "\n";
		os << "using Func = FUNCTION_PTR_SIGNATURE;" << "\n";
		os << "constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;" << "\n";
		os << "};" << "\n";
		os << "using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;" << "\n";

		os << "namespace // anonymous namespace" << "\n";
		os << "{" << "\n";
		os << "inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE" << std::to_string(index) << "(" << "\n";
		os << "[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)" << "\n";
		os << "{" << "\n";
		{
			GenerateFunctionStorageBody(ctx, os, index);
		}
		os << "});" << "\n";
		os << "} // anonymous namespace" << "\n";
		os << "} // __internal__" << "\n";
	}
	os << "#undef FUNCTION_STORAGE_ARGS" << "\n";
	os << "#undef FUNCTION_NAME" << "\n";
	os << "#undef FUNCTION_SIGNATURE" << "\n";
	os << "#undef FUNCTION_PTR_SIGNATURE" << "\n";
	os << "#undef FUNCTION_INDEX" << "\n";
	os << "#undef FUNCTION_INVOKER" << "\n";
	os << "#undef FUNCTION_LAMBDA_SIGNATURE" << "\n";
}

void ReflectedClass::GenerateFunctionStorageBody(clang::ASTContext* ctx, llvm::raw_ostream& os, int index)
{
	os << "self->m_Name = \"" << m_Functions[index]->getName() << "\";" << "\n";
	os << "self->m_ReturnType = GetType<" << Utils::RemoveAnonymousTag(GetDesugaredType(ctx, m_Functions[index]->getReturnType()).getAsString(m_PrintingPolicy)) << ">(); " << "\n";

	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		clang::ParmVarDecl* paramDecl = m_Functions[index]->parameters()[i];
		os << "// parameter \"" << paramDecl->getType().getAsString(m_PrintingPolicy) << " " << paramDecl->getName().str() << "\"" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetType(GetType<" << Utils::RemoveAnonymousTag(GetDesugaredType(ctx, paramDecl->getType()).getAsString(m_PrintingPolicy)) << ">()); " << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetOwnerType(nullptr);" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetName(\"" << paramDecl->getName().str() << "\");" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetOffset(0);" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetAccessSpecifier(" << GetAccessSpecifierString(paramDecl) << ");" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetQualifiers(" << GetQualifiersString(paramDecl) << ");" << "\n";
		os << "self->m_Parameters[" << std::to_string(i) << "].SetTypeSpecialization(" << GetTypeSpecializationString(paramDecl) << ");" << "\n";

		if (const clang::ConstantArrayType* arrayType = clang::dyn_cast<clang::ConstantArrayType>(paramDecl->getType()))
		{
			uint64_t lenght = *(arrayType->getSize().getRawData());
			os << "self->m_Parameters[" << std::to_string(i) << "].SetArraySize(" + std::to_string(lenght) + ");" << "\n";
		}
		else
		{
			os << "self->m_Parameters[" << std::to_string(i) << "].SetArraySize(0);" << "\n";
		}
		os << "\n";
	}

	os << "static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](" << GetFunctionLambdaParamsString(index) << ") -> " << m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy) << "\n";
	os << "{" << "\n";
	os << "CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);" << "\n";
	os << "if (o == nullptr) return (" << m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy) << ")0;" << "\n";
	os << "return (o->*FUNCTION_INVOKER::Invoke)(" << GetFunctionLambdaParamsPlacementString(index) << ");" << "\n";
	os << "};" << "\n";

	os << "self->m_InvokeFunc = FunctionLambda;" << "\n";
	os << "\n";
}

std::string ReflectedClass::GetFunctionStorageTemplateParamsString(int index)
{
	// in a 2 parameter functions, result should be: "2, ReturnType, Arg0Type, Arg1Type"
	std::string res;
	res += std::to_string(m_Functions[index]->getNumParams());
	res += ", " + m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy);
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		res += ", " + m_Functions[index]->parameters()[i]->getType().getAsString(m_PrintingPolicy);
	}

	return res;
}

std::string ReflectedClass::GetFunctionSignatureString(int index)
{
	// in a 2 parameter functions, result should be: "void(int, char)"
	std::string res;
	res += m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy);
	res += "(";
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		if (i != 0) res += ", ";
		res += m_Functions[index]->parameters()[i]->getType().getAsString(m_PrintingPolicy);
	}
	res += ")";
	return res;
}

std::string ReflectedClass::GetFunctionPtrSignatureString(int index)
{
	// in a 2 parameter functions, result should be: "void(CLASS_TYPE::*)(int, char) const"
	std::string res;
	if (m_Functions[index]->isConstexpr())
	{
		res += "constexpr ";
	}

	res += m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy);
	res += "(CLASS_TYPE::*)";
	res += "(";
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		if (i != 0) res += ", ";
		res += m_Functions[index]->parameters()[i]->getType().getAsString(m_PrintingPolicy);
	}
	res += ")";

	if (const clang::CXXMethodDecl* methodDecl = clang::dyn_cast<clang::CXXMethodDecl>(m_Functions[index]))
	{
		if (methodDecl->isConst())
		{
			res += " const";
		}
	}

	return res;
}

std::string ReflectedClass::GetFunctionLambdaSignatureString(int index)
{
	// in a 2 parameter functions, result should be: "void(void*, int, char)"
	std::string res;
	res += m_Functions[index]->getReturnType().getAsString(m_PrintingPolicy);
	res += "(void*";
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		res += ", ";
		res += m_Functions[index]->parameters()[i]->getType().getAsString(m_PrintingPolicy);
	}
	res += ")";
	return res;
}

std::string ReflectedClass::GetFunctionLambdaParamsString(int index)
{
	// in a 2 parameter functions, result should be: "void* obj, int arg0, char arg1"
	std::string res;
	res += "void* obj";
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		res += ", ";
		res += m_Functions[index]->parameters()[i]->getType().getAsString(m_PrintingPolicy) + " arg" + std::to_string(i);
	}

	return res;
}

std::string ReflectedClass::GetFunctionLambdaParamsPlacementString(int index)
{
	// in a 2 parameter functions, result should be: "arg0, arg1"
	std::string res;
	for (int i = 0; i < m_Functions[index]->parameters().size(); ++i)
	{
		if (i != 0) res += ", ";
		res += "arg" + std::to_string(i);
	}

	return res;
}

clang::QualType ReflectedClass::GetDesugaredType(clang::ASTContext* ctx, clang::QualType t)
{
	const clang::Type* type = t.split().Ty;

	const clang::BuiltinType* builtin = type->getAs<clang::BuiltinType>();
	if (builtin != nullptr)
	{
		return clang::QualType(builtin, 0);
	}

	const clang::RecordType* record = type->getAs<clang::RecordType>();
	if (record != nullptr)
	{
		return clang::QualType(record, 0);
	}

	/* Fallback to traversing the type manually. */
	TypeVisitor visitor(ctx);
	visitor.TraverseType(t);
	return clang::QualType(visitor.m_Leaf, 0);
}

std::string ReflectedClass::GetAccessSpecifierString(const clang::Decl* decl) const
{
	switch (decl->getAccess())
	{
	case clang::AccessSpecifier::AS_public:		return "AccessSpecifier::PUBLIC";
	case clang::AccessSpecifier::AS_protected:	return "AccessSpecifier::PROTECTED";
	case clang::AccessSpecifier::AS_private:	return "AccessSpecifier::PRIVATE";
	default:									return "AccessSpecifier::NONE";
	}
	return std::string();
}

std::string ReflectedClass::GetQualifiersString(const clang::ValueDecl* valueDecl) const
{
	/*
		NONE = 0,
		CONST = 1 << 0,
		VOLATILE = 1 << 1,
		MUTABLE = 1 << 2,
		AUTO = 1 << 3,
		REGISTER = 1 << 4,
		STATIC = 1 << 5,
		EXTERN = 1 << 6,
		INLINE = 1 << 7
	*/
	std::string res = "0x00";

	if (valueDecl->getType().isConstQualified())
	{
		res += " | Qualifier::CONST";
	}
	if (valueDecl->getType().isVolatileQualified())
	{
		res += " | Qualifier::VOLATILE";
	}
	if (const clang::FieldDecl* fieldDecl = clang::cast<clang::FieldDecl>(valueDecl))
	{
		if (fieldDecl->isMutable())
		{
			res += " | Qualifier::MUTABLE";
		}
	}
	if (const clang::VarDecl* varDecl = clang::cast<clang::VarDecl>(valueDecl))
	{
		if (varDecl->getStorageClass() == clang::SC_Auto)
		{
			res += " | Qualifier::AUTO";
		}
	}
	if (const clang::VarDecl* varDecl = clang::cast<clang::VarDecl>(valueDecl))
	{
		if (varDecl->getStorageClass() == clang::SC_Register)
		{
			res += " | Qualifier::REGISTER";
		}
	}
	if (const clang::VarDecl* varDecl = clang::cast<clang::VarDecl>(valueDecl))
	{
		if (varDecl->getStorageClass() == clang::SC_Static)
		{
			res += " | Qualifier::STATIC";
		}
	}
	if (const clang::VarDecl* varDecl = clang::cast<clang::VarDecl>(valueDecl))
	{
		if (varDecl->getStorageClass() == clang::SC_Extern)
		{
			res += " | Qualifier::EXTERN";
		}
	}

	// todo: add support to inline statics
	/*if (const clang::FieldDecl* fieldDecl = clang::cast<clang::FieldDecl>(valueDecl))
	{
		res += " | Qualifier::INLINE";
	}*/

	return res;
}

std::string ReflectedClass::GetTypeSpecializationString(const clang::ValueDecl* valueDecl) const
{
	std::string res = "0x00";

	if (valueDecl->getType()->isPointerType())
	{
		res += " | TypeSpec::POINTER";
	}
	if (valueDecl->getType()->isReferenceType())
	{
		res += " | TypeSpec::REFERENCE";
	}
	if (valueDecl->getType()->isConstantArrayType())
	{
		res += " | TypeSpec::ARRAY";
	}

	return res;
}

void ReflectedEnum::Generate(clang::ASTContext* ctx, llvm::raw_ostream& os)
{
	std::string prefix = Utils::GetFullScopeNamePrefix(m_EnumDecl->getParent(), true, "_");
	std::string enumName = m_EnumDecl->getName().str();
	size_t count = std::distance(m_EnumDecl->enumerator_begin(), m_EnumDecl->enumerator_end());

	os << "// -------------------------------------------------------" << "\n";
	os << "// This code was auto-generated by Heimdallr. DO NOT EDIT!" << "\n";
	os << "// -------------------------------------------------------" << "\n";
	os << "\n";
	os << "#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__" << "\n";
	{
		os << "#pragma once" << "\n";
		os << "#ifndef _HEIMDALLR_ENUM_" << prefix << enumName << "_REFLECTED_GENERATED_" << "\n";
		os << "#define _HEIMDALLR_ENUM_" << prefix << enumName << "_REFLECTED_GENERATED_" << "\n";
		{
			os << "\n";
			os << "#include \"heimdallr.h\"" << "\n";
			os << "#include \"" << m_FileName << "\"" << "\n";
			os << "\n";

			os << "#define ENUM_TYPE " << Utils::GetFullScopeNamePrefix(m_EnumDecl->getParent()) << enumName << "\n";
			os << "#define ENUM_COUNT " << std::to_string(count) << "\n";
			os << "#define ENUM_DEFAULT_VALUE_VARIABLE " << prefix << enumName << "_Heimdallr_Enum_DefaultValue" << "\n";
			os << "#define ENUM_INFO_VARIABLE " << prefix << enumName << "_Heimdallr_EnumInfo" << "\n";
			os << "#define ENUM_INFO_REGISTER_VARIABLE " << prefix << enumName << "_Heimdallr_EnumInfo_Register" << "\n";
			os << "#define ENUM_STORAGE_VARIABLE " << prefix << enumName << "_Heimdallr_EnumStorage" << "\n";
			os << "namespace hmdl" << "\n";
			os << "{" << "\n";

			GenerateEnum(ctx, os);

			os << "} // namespace hmdl" << "\n";
			os << "#undef ENUM_TYPE" << "\n";
			os << "#undef ENUM_COUNT" << "\n";
			os << "#undef ENUM_DEFAULT_VALUE_VARIABLE" << "\n";
			os << "#undef ENUM_INFO_VARIABLE" << "\n";
			os << "#undef ENUM_INFO_REGISTER_VARIABLE" << "\n";
			os << "#undef ENUM_STORAGE_VARIABLE" << "\n";

		}
		os << "#endif\n";
	}
	os << "#endif\n";
}

void ReflectedEnum::GenerateEnum(clang::ASTContext* ctx, llvm::raw_ostream& os)
{
	std::string enumName = m_EnumDecl->getName().str();

	os << "namespace __internal__" << "\n";
	os << "{" << "\n";
	{
		os << "namespace" << "\n";
		os << "{" << "\n";
		{
			os << "inline EnumStorage<ENUM_TYPE, ENUM_COUNT> ENUM_STORAGE_VARIABLE(" << "\n";
			os << "[](EnumStorage<ENUM_TYPE, ENUM_COUNT>* self)" << "\n";
			os << "{" << "\n";
			{ // values
				int index = 0;
				for (const clang::EnumConstantDecl* decl : m_EnumDecl->enumerators())
				{
					os << "self->m_Values[" << std::to_string(index) << "] = ENUM_TYPE::" << decl->getNameAsString() << ";" << "\n";
					++index;
				}
			}
			{ // values
				int index = 0;
				for (const clang::EnumConstantDecl* decl : m_EnumDecl->enumerators())
				{
					os << "self->m_Strings[" << std::to_string(index) << "] = \"" << decl->getNameAsString() << "\";" << "\n";
					++index;
				}
			}
			{ // value to string
				for (const clang::EnumConstantDecl* decl : m_EnumDecl->enumerators())
				{
					os << "self->m_ValueToString[ENUM_TYPE::" << decl->getNameAsString() << "] = \"" << decl->getNameAsString() << "\";" << "\n";
				}
			}
			{ // string to value
				for (const clang::EnumConstantDecl* decl : m_EnumDecl->enumerators())
				{
					os << "self->m_StringToValue[\"" << decl->getNameAsString() << "\"] = ENUM_TYPE::" << decl->getNameAsString() << ";" << "\n";
				}
			}
			{ // function pointers
				os << "static std::function<const char* (ENUM_TYPE)> EnumToStringLambda = [self](ENUM_TYPE e) -> const char*" << "\n";
				os << "{" << "\n";
				os << "	return self->m_ValueToString[e];" << "\n";
				os << "};" << "\n";
				os << "self->m_EnumToStringFunc = EnumToStringLambda;" << "\n";

				os << "static std::function<ENUM_TYPE(const char*)> StringToEnumLambda = [self](const char* str) -> ENUM_TYPE" << "\n";
				os << "{" << "\n";
				os << "	return self->m_StringToValue[str];" << "\n";
				os << "};" << "\n";
				os << "self->m_StringToEnumFunc = StringToEnumLambda;" << "\n";

				os << "static std::function<const char* (void*)> EnumAddrToStringLambda = [](void* addr) -> const char*" << "\n";
				os << "{" << "\n";
				os << "	return EnumToStringLambda(*reinterpret_cast<ENUM_TYPE*>(addr));" << "\n";
				os << "};" << "\n";
				os << "self->m_ValueAddrToStringFunc = EnumAddrToStringLambda;" << "\n";

				os << "static std::function<bool(const char*)> StringEnumExistsLambda = [self](const char* str) -> bool" << "\n";
				os << "{" << "\n";
				os << "	return self->m_StringToValue.find(str) != self->m_StringToValue.end();" << "\n";
				os << "};" << "\n";
				os << "self->m_StringEnumExistsFunc = StringEnumExistsLambda;" << "\n";

			}
			{	// attributes
				int index = 0;
				std::vector<std::string> attrs = Utils::GetAttributesList(m_EnumDecl);
				std::unordered_map<std::string, size_t> attrNameToCount;
				for (const std::string& attr : attrs)
				{
					auto pair = Utils::GetParsedAttribute(attr);
					std::string attrType = pair.first;
					std::string attrArgs = pair.second;
					std::string attrName = m_EnumDecl->getName().str() + "_enum_attr" + std::to_string(index);
					os << "static " << attrType << " " << attrName << " = { " << attrArgs << " };" << "\n";
					os << "self->m_Attributes.push_back(&" << attrName << ");" << "\n";
					++index;

					if (attrNameToCount.find(attrType) == attrNameToCount.end())
					{
						attrNameToCount[attrType] = 0;
					}
					++attrNameToCount[attrType];
				}

				// assertion
				for (auto attr : attrNameToCount)
				{
					os << "static_assert(" << attr.first << "::CanAllowMultiple() || " << std::to_string(attr.second) << " == 1, \"Cannot have multiple attributes of type " << attr.first << "\");" << "\n";
				}

			}
			os << "});" << "\n";
			os << "\n";

			std::string ownerClass = Utils::GetScopeName(clang::dyn_cast<clang::CXXRecordDecl>(m_EnumDecl->getParent()));
			os << "inline ENUM_TYPE ENUM_DEFAULT_VALUE_VARIABLE = {};" << "\n";
			os << "inline EnumInfo ENUM_INFO_VARIABLE" << "\n";
			os << "{" << "\n";
			os << "TypeInfo::InvalidID," << "\n";
			os << "\"" << enumName << "\"," << "\n";
			os << "\"" << Utils::GetFullScopeNamePrefix(m_EnumDecl->getParent()) << enumName << "\"," << "\n";
			os << "sizeof(ENUM_TYPE)," << "\n";
			os << "alignof(ENUM_TYPE)," << "\n";
			os << "&ENUM_DEFAULT_VALUE_VARIABLE," << "\n";
			os << "ENUM_STORAGE_VARIABLE.m_Strings.data()," << "\n";
			os << "ENUM_COUNT," << "\n";
			os << (ownerClass.empty() ? "nullptr," : ("GetType<" + ownerClass + ">(),")) << "\n";
			os << "&ENUM_STORAGE_VARIABLE.m_ValueAddrToStringFunc," << "\n";
			os << "&ENUM_STORAGE_VARIABLE.m_StringEnumExistsFunc," << "\n";
			os << "reinterpret_cast<std::function<void()>*>(&ENUM_STORAGE_VARIABLE.m_EnumToStringFunc)," << "\n";
			os << "reinterpret_cast<std::function<void()>*>(&ENUM_STORAGE_VARIABLE.m_StringToEnumFunc)," << "\n";
			os << "ENUM_STORAGE_VARIABLE.m_Attributes," << "\n";
			os << "};" << "\n";
			os << "\n";
			os << "inline hmdl::__internal__::registry::RegisterHelper ENUM_INFO_REGISTER_VARIABLE(&ENUM_INFO_VARIABLE);" << "\n";
		}
		os << "} // anonymous namespace" << "\n";

		os << "template<> const TypeInfo* GetTypeImpl(TemplatedTag<ENUM_TYPE>) noexcept" << "\n";
		os << "{" << "\n";
		os << "return GetEnum<ENUM_TYPE>();" << "\n";
		os << "}" << "\n";
		os << "\n";

		os << "template<> const EnumInfo* GetEnumImpl(TemplatedTag<ENUM_TYPE>) noexcept" << "\n";
		os << "{" << "\n";
		os << "return &ENUM_INFO_VARIABLE;" << "\n";
		os << "}" << "\n";
		os << "\n";

		os << "template<> const char* EnumToStringImpl(TemplatedTag<ENUM_TYPE>, ENUM_TYPE e) noexcept" << "\n";
		os << "{" << "\n";
		os << "return ENUM_STORAGE_VARIABLE.m_ValueToString[e];" << "\n";
		os << "}" << "\n";
		os << "\n";

		os << "template<> ENUM_TYPE StringToEnumImpl(TemplatedTag<ENUM_TYPE>, const char* str) noexcept" << "\n";
		os << "{" << "\n";
		os << "return ENUM_STORAGE_VARIABLE.m_StringToValue[str];" << "\n";
		os << "}" << "\n";
		os << "\n";
	}
	os << "} // __internal__" << "\n";

	os << "template<> ENUM_TYPE* EnumRange<ENUM_TYPE>::begin() const { return ENUM_COUNT > 0 ? &__internal__::ENUM_STORAGE_VARIABLE.m_Values[0] : nullptr; };" << "\n";
	os << "template<> ENUM_TYPE* EnumRange<ENUM_TYPE>::end() const { return ENUM_COUNT > 0 ? &__internal__::ENUM_STORAGE_VARIABLE.m_Values[0] + ENUM_COUNT : nullptr; };" << "\n";
	os << "\n";

}

std::string Utils::GetScopeName(const clang::DeclContext* context)
{
	if (const clang::CXXRecordDecl* record = clang::dyn_cast<clang::CXXRecordDecl>(context))
	{
		return record->getNameAsString();
	}
	else if (const clang::NamespaceDecl* namespaceDecl = clang::dyn_cast<clang::NamespaceDecl>(context))
	{
		return namespaceDecl->getNameAsString();
	}

	// global scope
	return std::string();
}

std::string Utils::GetFullScopeName(const clang::DeclContext* context, bool useSeparatorForAnonyms, const char* separator)
{
	if (context == nullptr) return std::string();
	std::string parent = GetFullScopeName(context->getParent());

	std::string scopeName = GetScopeName(context);
	bool isAnonymous = scopeName.empty();

	return (parent.empty() ? scopeName : parent + ((isAnonymous && useSeparatorForAnonyms) || !isAnonymous ? separator : "") + scopeName);
}

std::string Utils::GetFullScopeNamePrefix(const clang::DeclContext* context, bool useSeparatorForAnonyms, const char* separator)
{
	std::string name = GetFullScopeName(context, useSeparatorForAnonyms, separator);
	return name.empty() ? "" : name + separator;
}

std::string Utils::RemoveAnonymousTag(const std::string& str)
{
	std::regex patternNS("\\(anonymous namespace\\)::");
	// todo: add other anonymous tags

	return std::regex_replace(str, patternNS, "");
}

std::string Utils::GetAttributes(const clang::Decl* decl)
{
	//if (decl == nullptr) return "";

	clang::AnnotateAttr* annotateAttr = decl->getAttr<clang::AnnotateAttr>();
	if (annotateAttr == nullptr) return std::string();

	std::string notes = annotateAttr->getAnnotation().str();
	size_t pos = notes.find("heimdallr-attrs:");

	// check if "heimdallr-attrs:" was found
	if (pos != std::string::npos) {
		// remove everything from the beginning of the string until "heimdallr-attrs:"
		notes = notes.erase(0, pos + std::strlen("heimdallr-attrs:"));
	}
	else {
		// handle the case when "heimdallr-attrs:" is not found
		printf("\"heimdallr-attrs:\" not found in the attributes\n");
		notes = "";
	}

	return notes;
}

std::vector<std::string> Utils::GetAttributesList(const clang::Decl* decl)
{
	std::string input = GetAttributes(decl);
	std::vector<std::string> result;

	// todo: this regex picks the white space next to a comma (Attr(), Attr())
	std::regex pattern(R"(([^,()]*\([^()]*\)[^,]*)|[^,]+)");
	// Use std::sregex_token_iterator to split the string using the pattern
	std::sregex_token_iterator begin(input.begin(), input.end(), pattern);
	std::sregex_token_iterator end;

	for (auto it = begin; it != end; ++it) {
		result.push_back(*it);
	}

	return result;
}

std::pair<std::string, std::string> Utils::GetParsedAttribute(const std::string& attrStr)
{
	// accepted formats are:
	// Attribute(args)
	// Attribute
	// Attribute = arg
	// Attribute = (arg0, arg1, ...)
	std::string attributeName = "";
	std::string attributeArgs = "";

	std::regex pattern("^\\s*(\\w+)\\s*(?:\\(([^)]*)\\))?(?:\\s*=\\s*(?:\\(([^)]*)\\)|([^,]+(?:,\\s*[^,]+)*)))?");

	std::smatch match;
	if (std::regex_match(attrStr, match, pattern))
	{
		attributeName = match[1];
		attributeArgs = match[2];

		// has assignment sign
		if (attrStr.find('=') != std::string::npos)
		{
			attributeArgs = !match[3].str().empty() ? match[3] : match[4];
		}
	}

	return { attributeName, attributeArgs };
}

