// -------------------------------------------------------
// This code was auto-generated by Heimdallr. DO NOT EDIT!
// -------------------------------------------------------

#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__
#pragma once
#ifndef _HEIMDALLR_MyNameSpace__TestStruct_REFLECTED_GENERATED_
#define _HEIMDALLR_MyNameSpace__TestStruct_REFLECTED_GENERATED_

#include "heimdallr.h"
#include "D:\gtada\Desktop\Repositorio_GitHUB\heimdallr\tools\..\Sandbox\src/Test.h"

#define CLASS_TYPE MyNameSpace::TestStruct
#define CLASS_PARENT_CLASSES_COUNT 0
#define CLASS_PROPERTIES_COUNT 2
#define CLASS_FUNCTIONS_COUNT 0
#define CLASS_TEMPLATED_ARGS_COUNT 0

namespace hmdl
{
#define CLASS_STORAGE_VARIABLE MyNameSpace__TestStruct_Heimdallr_ClassStorage
#define CLASS_STORAGE_ARGS CLASS_TYPE, CLASS_PARENT_CLASSES_COUNT, CLASS_PROPERTIES_COUNT, CLASS_FUNCTIONS_COUNT, CLASS_TEMPLATED_ARGS_COUNT

namespace __internal__
{
namespace // anonymous namespace
{
inline ClassStorage<CLASS_STORAGE_ARGS> CLASS_STORAGE_VARIABLE(
[](ClassStorage<CLASS_STORAGE_ARGS>* self)
{
// begin parent classes metadata
// end parent classes metadata
// property "bool[5] colors"
self->m_Fields[0].SetType(GetType<bool>());
self->m_Fields[0].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[0].SetName("colors");
self->m_Fields[0].SetOffset(0);
self->m_Fields[0].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[0].SetQualifiers(0x00);
self->m_Fields[0].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[0].SetArraySize(5);
self->m_Fields[0].SetComment("");

// property "char c"
self->m_Fields[1].SetType(GetType<char>());
self->m_Fields[1].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[1].SetName("c");
self->m_Fields[1].SetOffset(5);
self->m_Fields[1].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[1].SetQualifiers(0x00);
self->m_Fields[1].SetTypeSpecialization(0x00);
self->m_Fields[1].SetArraySize(0);
self->m_Fields[1].SetComment("");

self->m_Comment = "";
static DisplayName TestStruct_class_attr0 = { "MY_SUPER_STRUCT" };
self->m_Attributes.push_back(&TestStruct_class_attr0);
static_assert(DisplayName::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type DisplayName");
}
);

#define CLASS_DEFAULT_VALUE_VARIABLE MyNameSpace__TestStruct_Heimdallr_Class_DefaultValue
#define CLASS_INFO_VARIABLE MyNameSpace__TestStruct_Heimdallr_ClassInfo
#define CLASS_INFO_REGISTER_VARIABLE MyNameSpace__TestStruct_Heimdallr_ClassInfo_Register
inline CLASS_TYPE CLASS_DEFAULT_VALUE_VARIABLE = {};
inline ClassInfo CLASS_INFO_VARIABLE
{
TypeInfo::InvalidID,
"TestStruct",
"MyNameSpace::TestStruct",
sizeof(CLASS_TYPE),
alignof(CLASS_TYPE),
&CLASS_DEFAULT_VALUE_VARIABLE,
CLASS_STORAGE_VARIABLE.m_ParentClasses.data(),
CLASS_STORAGE_VARIABLE.ParentClassesCount,
CLASS_STORAGE_VARIABLE.m_Fields.data(),
CLASS_STORAGE_VARIABLE.FieldsCount,
CLASS_STORAGE_VARIABLE.m_Functions.data(),
CLASS_STORAGE_VARIABLE.FunctionsCount,
CLASS_STORAGE_VARIABLE.m_Comment,
CLASS_STORAGE_VARIABLE.m_Attributes
};

inline hmdl::__internal__::registry::RegisterHelper CLASS_INFO_REGISTER_VARIABLE(&CLASS_INFO_VARIABLE);
} // anonymous namespace
template<> const TypeInfo* GetTypeImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return GetClass<CLASS_TYPE>();
}

template<> const ClassInfo* GetClassImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return &CLASS_INFO_VARIABLE;
}

} // __internal__
#undef CLASS_DEFAULT_VALUE_VARIABLE
#undef CLASS_STORAGE_VARIABLE
#undef CLASS_STORAGE_ARGS
#undef CLASS_INFO_VARIABLE
#undef CLASS_INFO_REGISTER_VARIABLE
} // namespace hmdl
#undef CLASS_TYPE
#undef CLASS_PARENT_CLASSES_COUNT
#undef CLASS_PROPERTIES_COUNT
#undef CLASS_FUNCTIONS_COUNT
#undef CLASS_TEMPLATED_ARGS_COUNT
#endif
#endif
// -------------------------------------------------------
// This code was auto-generated by Heimdallr. DO NOT EDIT!
// -------------------------------------------------------

#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__
#pragma once
#ifndef _HEIMDALLR_NonAnonymNS_REFLECTED_GENERATED_
#define _HEIMDALLR_NonAnonymNS_REFLECTED_GENERATED_

#include "heimdallr.h"
#include "D:\gtada\Desktop\Repositorio_GitHUB\heimdallr\tools\..\Sandbox\src/Test.h"

#define CLASS_TYPE NonAnonymNS
#define CLASS_PARENT_CLASSES_COUNT 0
#define CLASS_PROPERTIES_COUNT 0
#define CLASS_FUNCTIONS_COUNT 0
#define CLASS_TEMPLATED_ARGS_COUNT 0

namespace hmdl
{
#define CLASS_STORAGE_VARIABLE NonAnonymNS_Heimdallr_ClassStorage
#define CLASS_STORAGE_ARGS CLASS_TYPE, CLASS_PARENT_CLASSES_COUNT, CLASS_PROPERTIES_COUNT, CLASS_FUNCTIONS_COUNT, CLASS_TEMPLATED_ARGS_COUNT

namespace __internal__
{
namespace // anonymous namespace
{
inline ClassStorage<CLASS_STORAGE_ARGS> CLASS_STORAGE_VARIABLE(
[](ClassStorage<CLASS_STORAGE_ARGS>* self)
{
// begin parent classes metadata
// end parent classes metadata
self->m_Comment = "Esta clase es una clase muy chida";
}
);

#define CLASS_DEFAULT_VALUE_VARIABLE NonAnonymNS_Heimdallr_Class_DefaultValue
#define CLASS_INFO_VARIABLE NonAnonymNS_Heimdallr_ClassInfo
#define CLASS_INFO_REGISTER_VARIABLE NonAnonymNS_Heimdallr_ClassInfo_Register
inline CLASS_TYPE CLASS_DEFAULT_VALUE_VARIABLE = {};
inline ClassInfo CLASS_INFO_VARIABLE
{
TypeInfo::InvalidID,
"NonAnonymNS",
"NonAnonymNS",
sizeof(CLASS_TYPE),
alignof(CLASS_TYPE),
&CLASS_DEFAULT_VALUE_VARIABLE,
CLASS_STORAGE_VARIABLE.m_ParentClasses.data(),
CLASS_STORAGE_VARIABLE.ParentClassesCount,
CLASS_STORAGE_VARIABLE.m_Fields.data(),
CLASS_STORAGE_VARIABLE.FieldsCount,
CLASS_STORAGE_VARIABLE.m_Functions.data(),
CLASS_STORAGE_VARIABLE.FunctionsCount,
CLASS_STORAGE_VARIABLE.m_Comment,
CLASS_STORAGE_VARIABLE.m_Attributes
};

inline hmdl::__internal__::registry::RegisterHelper CLASS_INFO_REGISTER_VARIABLE(&CLASS_INFO_VARIABLE);
} // anonymous namespace
template<> const TypeInfo* GetTypeImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return GetClass<CLASS_TYPE>();
}

template<> const ClassInfo* GetClassImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return &CLASS_INFO_VARIABLE;
}

} // __internal__
#undef CLASS_DEFAULT_VALUE_VARIABLE
#undef CLASS_STORAGE_VARIABLE
#undef CLASS_STORAGE_ARGS
#undef CLASS_INFO_VARIABLE
#undef CLASS_INFO_REGISTER_VARIABLE
} // namespace hmdl
#undef CLASS_TYPE
#undef CLASS_PARENT_CLASSES_COUNT
#undef CLASS_PROPERTIES_COUNT
#undef CLASS_FUNCTIONS_COUNT
#undef CLASS_TEMPLATED_ARGS_COUNT
#endif
#endif
// -------------------------------------------------------
// This code was auto-generated by Heimdallr. DO NOT EDIT!
// -------------------------------------------------------

#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__
#pragma once
#ifndef _HEIMDALLR_NonAnonymNS_TestStruct_REFLECTED_GENERATED_
#define _HEIMDALLR_NonAnonymNS_TestStruct_REFLECTED_GENERATED_

#include "heimdallr.h"
#include "D:\gtada\Desktop\Repositorio_GitHUB\heimdallr\tools\..\Sandbox\src/Test.h"

#define CLASS_TYPE NonAnonymNS::TestStruct
#define CLASS_PARENT_CLASSES_COUNT 0
#define CLASS_PROPERTIES_COUNT 2
#define CLASS_FUNCTIONS_COUNT 3
#define CLASS_TEMPLATED_ARGS_COUNT 0

namespace hmdl
{
#define FUNCTION_STORAGE_VARIABLE0 NonAnonymNS_TestStruct_MyVoidFunction0_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 1, void, char
#define FUNCTION_NAME MyVoidFunction
#define FUNCTION_SIGNATURE void(char)
#define FUNCTION_PTR_SIGNATURE void(CLASS_TYPE::*)(char) const
#define FUNCTION_INDEX 0
#define FUNCTION_INVOKER NonAnonymNS_TestStruct_MyVoidFunction0_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE void(void*, char)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE0(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyVoidFunction";
self->m_ReturnType = GetType<void>(); 
// parameter "char c"
self->m_Parameters[0].SetType(GetType<char>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, char arg0) -> void
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (void)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "Esto es un comentario para una funcion muy chula xD";
self->m_ReturnComment = "";
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE1 NonAnonymNS_TestStruct_MyVoidFunction1_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 1, void, int
#define FUNCTION_NAME MyVoidFunction
#define FUNCTION_SIGNATURE void(int)
#define FUNCTION_PTR_SIGNATURE void(CLASS_TYPE::*)(int) const
#define FUNCTION_INDEX 1
#define FUNCTION_INVOKER NonAnonymNS_TestStruct_MyVoidFunction1_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE void(void*, int)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE1(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyVoidFunction";
self->m_ReturnType = GetType<void>(); 
// parameter "int c"
self->m_Parameters[0].SetType(GetType<int>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, int arg0) -> void
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (void)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "JEJEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\nJEJEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\nJEJEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE";
self->m_ReturnComment = "";
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE2 NonAnonymNS_TestStruct_MyVoidFunction2_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 1, void, bool
#define FUNCTION_NAME MyVoidFunction
#define FUNCTION_SIGNATURE void(bool)
#define FUNCTION_PTR_SIGNATURE void(CLASS_TYPE::*)(bool) const
#define FUNCTION_INDEX 2
#define FUNCTION_INVOKER NonAnonymNS_TestStruct_MyVoidFunction2_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE void(void*, bool)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE2(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyVoidFunction";
self->m_ReturnType = GetType<void>(); 
// parameter "bool c"
self->m_Parameters[0].SetType(GetType<bool>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, bool arg0) -> void
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (void)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "JEJEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE";
self->m_ReturnComment = "";
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define CLASS_STORAGE_VARIABLE NonAnonymNS_TestStruct_Heimdallr_ClassStorage
#define CLASS_STORAGE_ARGS CLASS_TYPE, CLASS_PARENT_CLASSES_COUNT, CLASS_PROPERTIES_COUNT, CLASS_FUNCTIONS_COUNT, CLASS_TEMPLATED_ARGS_COUNT

namespace __internal__
{
namespace // anonymous namespace
{
inline ClassStorage<CLASS_STORAGE_ARGS> CLASS_STORAGE_VARIABLE(
[](ClassStorage<CLASS_STORAGE_ARGS>* self)
{
// begin parent classes metadata
// end parent classes metadata
// property "bool[5] colors"
self->m_Fields[0].SetType(GetType<bool>());
self->m_Fields[0].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[0].SetName("colors");
self->m_Fields[0].SetOffset(0);
self->m_Fields[0].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[0].SetQualifiers(0x00);
self->m_Fields[0].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[0].SetArraySize(5);
self->m_Fields[0].SetComment("Que chulada de comentario");

// property "char c"
self->m_Fields[1].SetType(GetType<char>());
self->m_Fields[1].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[1].SetName("c");
self->m_Fields[1].SetOffset(5);
self->m_Fields[1].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[1].SetQualifiers(0x00);
self->m_Fields[1].SetTypeSpecialization(0x00);
self->m_Fields[1].SetArraySize(0);
self->m_Fields[1].SetComment("Que chulada de comentario\nPero no sabria decirte");

self->m_Functions[0].SetName(FUNCTION_STORAGE_VARIABLE0.m_Name);
self->m_Functions[0].SetReturnType(FUNCTION_STORAGE_VARIABLE0.m_ReturnType);
self->m_Functions[0].SetParameters(FUNCTION_STORAGE_VARIABLE0.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE0.m_Parameters.size());
self->m_Functions[0].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE0.m_InvokeFunc);
self->m_Functions[0].SetComment(FUNCTION_STORAGE_VARIABLE0.m_Comment);
self->m_Functions[0].SetReturnComment(FUNCTION_STORAGE_VARIABLE0.m_ReturnComment);
self->m_Functions[1].SetName(FUNCTION_STORAGE_VARIABLE1.m_Name);
self->m_Functions[1].SetReturnType(FUNCTION_STORAGE_VARIABLE1.m_ReturnType);
self->m_Functions[1].SetParameters(FUNCTION_STORAGE_VARIABLE1.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE1.m_Parameters.size());
self->m_Functions[1].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE1.m_InvokeFunc);
self->m_Functions[1].SetComment(FUNCTION_STORAGE_VARIABLE1.m_Comment);
self->m_Functions[1].SetReturnComment(FUNCTION_STORAGE_VARIABLE1.m_ReturnComment);
self->m_Functions[2].SetName(FUNCTION_STORAGE_VARIABLE2.m_Name);
self->m_Functions[2].SetReturnType(FUNCTION_STORAGE_VARIABLE2.m_ReturnType);
self->m_Functions[2].SetParameters(FUNCTION_STORAGE_VARIABLE2.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE2.m_Parameters.size());
self->m_Functions[2].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE2.m_InvokeFunc);
self->m_Functions[2].SetComment(FUNCTION_STORAGE_VARIABLE2.m_Comment);
self->m_Functions[2].SetReturnComment(FUNCTION_STORAGE_VARIABLE2.m_ReturnComment);
self->m_Comment = "";
static DisplayName TestStruct_class_attr0 = { "MY_NOT_THAT_SUPER_STRUCT" };
self->m_Attributes.push_back(&TestStruct_class_attr0);
static_assert(DisplayName::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type DisplayName");
}
);

#define CLASS_DEFAULT_VALUE_VARIABLE NonAnonymNS_TestStruct_Heimdallr_Class_DefaultValue
#define CLASS_INFO_VARIABLE NonAnonymNS_TestStruct_Heimdallr_ClassInfo
#define CLASS_INFO_REGISTER_VARIABLE NonAnonymNS_TestStruct_Heimdallr_ClassInfo_Register
inline CLASS_TYPE CLASS_DEFAULT_VALUE_VARIABLE = {};
inline ClassInfo CLASS_INFO_VARIABLE
{
TypeInfo::InvalidID,
"TestStruct",
"NonAnonymNS::TestStruct",
sizeof(CLASS_TYPE),
alignof(CLASS_TYPE),
&CLASS_DEFAULT_VALUE_VARIABLE,
CLASS_STORAGE_VARIABLE.m_ParentClasses.data(),
CLASS_STORAGE_VARIABLE.ParentClassesCount,
CLASS_STORAGE_VARIABLE.m_Fields.data(),
CLASS_STORAGE_VARIABLE.FieldsCount,
CLASS_STORAGE_VARIABLE.m_Functions.data(),
CLASS_STORAGE_VARIABLE.FunctionsCount,
CLASS_STORAGE_VARIABLE.m_Comment,
CLASS_STORAGE_VARIABLE.m_Attributes
};

inline hmdl::__internal__::registry::RegisterHelper CLASS_INFO_REGISTER_VARIABLE(&CLASS_INFO_VARIABLE);
} // anonymous namespace
template<> const TypeInfo* GetTypeImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return GetClass<CLASS_TYPE>();
}

template<> const ClassInfo* GetClassImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return &CLASS_INFO_VARIABLE;
}

} // __internal__
#undef CLASS_DEFAULT_VALUE_VARIABLE
#undef CLASS_STORAGE_VARIABLE
#undef CLASS_STORAGE_ARGS
#undef CLASS_INFO_VARIABLE
#undef CLASS_INFO_REGISTER_VARIABLE
} // namespace hmdl
#undef FUNCTION_STORAGE_VARIABLE0
#undef FUNCTION_STORAGE_VARIABLE1
#undef FUNCTION_STORAGE_VARIABLE2
#undef CLASS_TYPE
#undef CLASS_PARENT_CLASSES_COUNT
#undef CLASS_PROPERTIES_COUNT
#undef CLASS_FUNCTIONS_COUNT
#undef CLASS_TEMPLATED_ARGS_COUNT
#endif
#endif
// -------------------------------------------------------
// This code was auto-generated by Heimdallr. DO NOT EDIT!
// -------------------------------------------------------

#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__
#pragma once
#ifndef _HEIMDALLR_TestClass_REFLECTED_GENERATED_
#define _HEIMDALLR_TestClass_REFLECTED_GENERATED_

#include "heimdallr.h"
#include "D:\gtada\Desktop\Repositorio_GitHUB\heimdallr\tools\..\Sandbox\src/Test.h"

#define CLASS_TYPE TestClass
#define CLASS_PARENT_CLASSES_COUNT 1
#define CLASS_PROPERTIES_COUNT 11
#define CLASS_FUNCTIONS_COUNT 5
#define CLASS_TEMPLATED_ARGS_COUNT 0

namespace hmdl
{
#define FUNCTION_STORAGE_VARIABLE0 TestClass_MyFunctionWithNameX0_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 2, bool, char, bool
#define FUNCTION_NAME MyFunctionWithNameX
#define FUNCTION_SIGNATURE bool(char, bool)
#define FUNCTION_PTR_SIGNATURE bool(CLASS_TYPE::*)(char, bool) const
#define FUNCTION_INDEX 0
#define FUNCTION_INVOKER TestClass_MyFunctionWithNameX0_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE bool(void*, char, bool)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE0(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyFunctionWithNameX";
self->m_ReturnType = GetType<bool>(); 
// parameter "char c"
self->m_Parameters[0].SetType(GetType<char>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("Coas que Pasan\n");

// parameter "bool isAwaken"
self->m_Parameters[1].SetType(GetType<bool>()); 
self->m_Parameters[1].SetOwnerType(nullptr);
self->m_Parameters[1].SetName("isAwaken");
self->m_Parameters[1].SetOffset(0);
self->m_Parameters[1].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[1].SetQualifiers(0x00);
self->m_Parameters[1].SetTypeSpecialization(0x00);
self->m_Parameters[1].SetArraySize(0);
self->m_Parameters[1].SetComment("Estas despierto o no?\n");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, char arg0, bool arg1) -> bool
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (bool)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0, arg1);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "Te amo mi amor.\n\n@param c Coas que Pasan\n\n@param isAwaken Estas despierto o no?\n\n@return Lo que devuelve";
self->m_ReturnComment = "Lo que devuelve";
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE1 TestClass_MyFunctionWithNameXYZ1_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 2, bool, char, bool
#define FUNCTION_NAME MyFunctionWithNameXYZ
#define FUNCTION_SIGNATURE bool(char, bool)
#define FUNCTION_PTR_SIGNATURE bool(CLASS_TYPE::*)(char, bool) const
#define FUNCTION_INDEX 1
#define FUNCTION_INVOKER TestClass_MyFunctionWithNameXYZ1_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE bool(void*, char, bool)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE1(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyFunctionWithNameXYZ";
self->m_ReturnType = GetType<bool>(); 
// parameter "char c"
self->m_Parameters[0].SetType(GetType<char>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

// parameter "bool isAwaken"
self->m_Parameters[1].SetType(GetType<bool>()); 
self->m_Parameters[1].SetOwnerType(nullptr);
self->m_Parameters[1].SetName("isAwaken");
self->m_Parameters[1].SetOffset(0);
self->m_Parameters[1].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[1].SetQualifiers(0x00);
self->m_Parameters[1].SetTypeSpecialization(0x00);
self->m_Parameters[1].SetArraySize(0);
self->m_Parameters[1].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, char arg0, bool arg1) -> bool
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (bool)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0, arg1);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "";
self->m_ReturnComment = "";
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE2 TestClass_MyFunctionWithNameX2_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 2, bool, char, int
#define FUNCTION_NAME MyFunctionWithNameX
#define FUNCTION_SIGNATURE bool(char, int)
#define FUNCTION_PTR_SIGNATURE bool(CLASS_TYPE::*)(char, int) const
#define FUNCTION_INDEX 2
#define FUNCTION_INVOKER TestClass_MyFunctionWithNameX2_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE bool(void*, char, int)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE2(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyFunctionWithNameX";
self->m_ReturnType = GetType<bool>(); 
// parameter "char c"
self->m_Parameters[0].SetType(GetType<char>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

// parameter "int a"
self->m_Parameters[1].SetType(GetType<int>()); 
self->m_Parameters[1].SetOwnerType(nullptr);
self->m_Parameters[1].SetName("a");
self->m_Parameters[1].SetOffset(0);
self->m_Parameters[1].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[1].SetQualifiers(0x00);
self->m_Parameters[1].SetTypeSpecialization(0x00);
self->m_Parameters[1].SetArraySize(0);
self->m_Parameters[1].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, char arg0, int arg1) -> bool
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (bool)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0, arg1);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "";
self->m_ReturnComment = "";
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE3 TestClass_MyVoidFunction3_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 1, void, char
#define FUNCTION_NAME MyVoidFunction
#define FUNCTION_SIGNATURE void(char)
#define FUNCTION_PTR_SIGNATURE void(CLASS_TYPE::*)(char) const
#define FUNCTION_INDEX 3
#define FUNCTION_INVOKER TestClass_MyVoidFunction3_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE void(void*, char)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE3(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "MyVoidFunction";
self->m_ReturnType = GetType<void>(); 
// parameter "char c"
self->m_Parameters[0].SetType(GetType<char>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("c");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, char arg0) -> void
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (void)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "";
self->m_ReturnComment = "";
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define FUNCTION_STORAGE_VARIABLE4 TestClass_PrintXReturnY4_Heimdallr_FunctionStorage
#define FUNCTION_STORAGE_ARGS 2, int, int, int
#define FUNCTION_NAME PrintXReturnY
#define FUNCTION_SIGNATURE int(int, int)
#define FUNCTION_PTR_SIGNATURE int(CLASS_TYPE::*)(int, int) const
#define FUNCTION_INDEX 4
#define FUNCTION_INVOKER TestClass_PrintXReturnY4_Heimdallr_FunctionInvoker
#define FUNCTION_LAMBDA_SIGNATURE int(void*, int, int)
namespace __internal__
{
template<> struct FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>
{
using Func = FUNCTION_PTR_SIGNATURE;
constexpr static Func Invoke = &CLASS_TYPE::FUNCTION_NAME;
};
using FUNCTION_INVOKER = FunctionInvoker<CLASS_TYPE, FUNCTION_PTR_SIGNATURE, FUNCTION_INDEX>;
namespace // anonymous namespace
{
inline FunctionStorage<FUNCTION_STORAGE_ARGS> FUNCTION_STORAGE_VARIABLE4(
[](FunctionStorage<FUNCTION_STORAGE_ARGS>* self)
{
self->m_Name = "PrintXReturnY";
self->m_ReturnType = GetType<int>(); 
// parameter "int X"
self->m_Parameters[0].SetType(GetType<int>()); 
self->m_Parameters[0].SetOwnerType(nullptr);
self->m_Parameters[0].SetName("X");
self->m_Parameters[0].SetOffset(0);
self->m_Parameters[0].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[0].SetQualifiers(0x00);
self->m_Parameters[0].SetTypeSpecialization(0x00);
self->m_Parameters[0].SetArraySize(0);
self->m_Parameters[0].SetComment("");

// parameter "int Y"
self->m_Parameters[1].SetType(GetType<int>()); 
self->m_Parameters[1].SetOwnerType(nullptr);
self->m_Parameters[1].SetName("Y");
self->m_Parameters[1].SetOffset(0);
self->m_Parameters[1].SetAccessSpecifier(AccessSpecifier::NONE);
self->m_Parameters[1].SetQualifiers(0x00);
self->m_Parameters[1].SetTypeSpecialization(0x00);
self->m_Parameters[1].SetArraySize(0);
self->m_Parameters[1].SetComment("");

static std::function<FUNCTION_LAMBDA_SIGNATURE> FunctionLambda = [](void* obj, int arg0, int arg1) -> int
{
CLASS_TYPE* o = static_cast<CLASS_TYPE*>(obj);
if (o == nullptr) return (int)0;
return (o->*FUNCTION_INVOKER::Invoke)(arg0, arg1);
};
self->m_InvokeFunc = FunctionLambda;

self->m_Comment = "";
self->m_ReturnComment = "";
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
});
} // anonymous namespace
} // __internal__
#undef FUNCTION_STORAGE_ARGS
#undef FUNCTION_NAME
#undef FUNCTION_SIGNATURE
#undef FUNCTION_PTR_SIGNATURE
#undef FUNCTION_INDEX
#undef FUNCTION_INVOKER
#undef FUNCTION_LAMBDA_SIGNATURE
#define CLASS_STORAGE_VARIABLE TestClass_Heimdallr_ClassStorage
#define CLASS_STORAGE_ARGS CLASS_TYPE, CLASS_PARENT_CLASSES_COUNT, CLASS_PROPERTIES_COUNT, CLASS_FUNCTIONS_COUNT, CLASS_TEMPLATED_ARGS_COUNT

namespace __internal__
{
namespace // anonymous namespace
{
inline ClassStorage<CLASS_STORAGE_ARGS> CLASS_STORAGE_VARIABLE(
[](ClassStorage<CLASS_STORAGE_ARGS>* self)
{
// begin parent classes metadata
self->m_ParentClasses[0] = GetClass<struct NonAnonymNS::TestStruct>();
// end parent classes metadata
// property "char[7] name2"
self->m_Fields[0].SetType(GetType<char>());
self->m_Fields[0].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[0].SetName("name2");
self->m_Fields[0].SetOffset(7);
self->m_Fields[0].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[0].SetQualifiers(0x00);
self->m_Fields[0].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[0].SetArraySize(7);
self->m_Fields[0].SetComment("");
static RangeSlider name2_field0_attr0 = { 5.0f, 10.0f };
self->m_Fields[0].m_Attributes.push_back(&name2_field0_attr0);
static Category name2_field0_attr1 = { "Hola a todos" };
self->m_Fields[0].m_Attributes.push_back(&name2_field0_attr1);
static HideInEditor name2_field0_attr2 = {  };
self->m_Fields[0].m_Attributes.push_back(&name2_field0_attr2);
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
static_assert(RangeSlider::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type RangeSlider");
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");

// property "std::string nunuName"
self->m_Fields[1].SetType(GetType<class std::basic_string<char>>());
self->m_Fields[1].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[1].SetName("nunuName");
self->m_Fields[1].SetOffset(16);
self->m_Fields[1].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[1].SetQualifiers(0x00);
self->m_Fields[1].SetTypeSpecialization(0x00);
self->m_Fields[1].SetArraySize(0);
self->m_Fields[1].SetComment("");

// property "MyCXXEnum[5] jahant"
self->m_Fields[2].SetType(GetType<enum TestClass::MyCXXEnum>());
self->m_Fields[2].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[2].SetName("jahant");
self->m_Fields[2].SetOffset(56);
self->m_Fields[2].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[2].SetQualifiers(0x00);
self->m_Fields[2].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[2].SetArraySize(5);
self->m_Fields[2].SetComment("");

// property "MyNameSpace::TestStruct[5] jaat"
self->m_Fields[3].SetType(GetType<struct MyNameSpace::TestStruct>());
self->m_Fields[3].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[3].SetName("jaat");
self->m_Fields[3].SetOffset(76);
self->m_Fields[3].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[3].SetQualifiers(0x00);
self->m_Fields[3].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[3].SetArraySize(5);
self->m_Fields[3].SetComment("");

// property "bool[8] nnoasd"
self->m_Fields[4].SetType(GetType<bool>());
self->m_Fields[4].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[4].SetName("nnoasd");
self->m_Fields[4].SetOffset(106);
self->m_Fields[4].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[4].SetQualifiers(0x00);
self->m_Fields[4].SetTypeSpecialization(0x00 | TypeSpec::ARRAY);
self->m_Fields[4].SetArraySize(8);
self->m_Fields[4].SetComment("");

// property "int count"
self->m_Fields[5].SetType(GetType<int>());
self->m_Fields[5].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[5].SetName("count");
self->m_Fields[5].SetOffset(116);
self->m_Fields[5].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[5].SetQualifiers(0x00);
self->m_Fields[5].SetTypeSpecialization(0x00);
self->m_Fields[5].SetArraySize(0);
self->m_Fields[5].SetComment("");

// property "float x"
self->m_Fields[6].SetType(GetType<float>());
self->m_Fields[6].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[6].SetName("x");
self->m_Fields[6].SetOffset(120);
self->m_Fields[6].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[6].SetQualifiers(0x00);
self->m_Fields[6].SetTypeSpecialization(0x00);
self->m_Fields[6].SetArraySize(0);
self->m_Fields[6].SetComment("");

// property "double y"
self->m_Fields[7].SetType(GetType<double>());
self->m_Fields[7].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[7].SetName("y");
self->m_Fields[7].SetOffset(128);
self->m_Fields[7].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[7].SetQualifiers(0x00);
self->m_Fields[7].SetTypeSpecialization(0x00);
self->m_Fields[7].SetArraySize(0);
self->m_Fields[7].SetComment("");

// property "char character"
self->m_Fields[8].SetType(GetType<char>());
self->m_Fields[8].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[8].SetName("character");
self->m_Fields[8].SetOffset(136);
self->m_Fields[8].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[8].SetQualifiers(0x00);
self->m_Fields[8].SetTypeSpecialization(0x00);
self->m_Fields[8].SetArraySize(0);
self->m_Fields[8].SetComment("");

// property "const char * name"
self->m_Fields[9].SetType(GetType<char>());
self->m_Fields[9].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[9].SetName("name");
self->m_Fields[9].SetOffset(144);
self->m_Fields[9].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[9].SetQualifiers(0x00);
self->m_Fields[9].SetTypeSpecialization(0x00 | TypeSpec::POINTER);
self->m_Fields[9].SetArraySize(0);
self->m_Fields[9].SetComment("");

// property "MyNameSpace::TestStruct testStruct"
self->m_Fields[10].SetType(GetType<struct MyNameSpace::TestStruct>());
self->m_Fields[10].SetOwnerType(GetType<CLASS_TYPE>());
self->m_Fields[10].SetName("testStruct");
self->m_Fields[10].SetOffset(152);
self->m_Fields[10].SetAccessSpecifier(AccessSpecifier::PUBLIC);
self->m_Fields[10].SetQualifiers(0x00);
self->m_Fields[10].SetTypeSpecialization(0x00);
self->m_Fields[10].SetArraySize(0);
self->m_Fields[10].SetComment("");

self->m_Functions[0].SetName(FUNCTION_STORAGE_VARIABLE0.m_Name);
self->m_Functions[0].SetReturnType(FUNCTION_STORAGE_VARIABLE0.m_ReturnType);
self->m_Functions[0].SetParameters(FUNCTION_STORAGE_VARIABLE0.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE0.m_Parameters.size());
self->m_Functions[0].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE0.m_InvokeFunc);
self->m_Functions[0].SetComment(FUNCTION_STORAGE_VARIABLE0.m_Comment);
self->m_Functions[0].SetReturnComment(FUNCTION_STORAGE_VARIABLE0.m_ReturnComment);
static Category MyFunctionWithNameX_func0_attr0 = { "Hola a todos" };
self->m_Functions[0].m_Attributes.push_back(&MyFunctionWithNameX_func0_attr0);
static HideInEditor MyFunctionWithNameX_func0_attr1 = {  };
self->m_Functions[0].m_Attributes.push_back(&MyFunctionWithNameX_func0_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
self->m_Functions[1].SetName(FUNCTION_STORAGE_VARIABLE1.m_Name);
self->m_Functions[1].SetReturnType(FUNCTION_STORAGE_VARIABLE1.m_ReturnType);
self->m_Functions[1].SetParameters(FUNCTION_STORAGE_VARIABLE1.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE1.m_Parameters.size());
self->m_Functions[1].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE1.m_InvokeFunc);
self->m_Functions[1].SetComment(FUNCTION_STORAGE_VARIABLE1.m_Comment);
self->m_Functions[1].SetReturnComment(FUNCTION_STORAGE_VARIABLE1.m_ReturnComment);
static Category MyFunctionWithNameXYZ_func1_attr0 = { "Hola a todos" };
self->m_Functions[1].m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr0);
static HideInEditor MyFunctionWithNameXYZ_func1_attr1 = {  };
self->m_Functions[1].m_Attributes.push_back(&MyFunctionWithNameXYZ_func1_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
self->m_Functions[2].SetName(FUNCTION_STORAGE_VARIABLE2.m_Name);
self->m_Functions[2].SetReturnType(FUNCTION_STORAGE_VARIABLE2.m_ReturnType);
self->m_Functions[2].SetParameters(FUNCTION_STORAGE_VARIABLE2.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE2.m_Parameters.size());
self->m_Functions[2].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE2.m_InvokeFunc);
self->m_Functions[2].SetComment(FUNCTION_STORAGE_VARIABLE2.m_Comment);
self->m_Functions[2].SetReturnComment(FUNCTION_STORAGE_VARIABLE2.m_ReturnComment);
static Category MyFunctionWithNameX_func2_attr0 = { "Hola a nadie" };
self->m_Functions[2].m_Attributes.push_back(&MyFunctionWithNameX_func2_attr0);
static HideInEditor MyFunctionWithNameX_func2_attr1 = {  };
self->m_Functions[2].m_Attributes.push_back(&MyFunctionWithNameX_func2_attr1);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
static_assert(HideInEditor::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type HideInEditor");
self->m_Functions[3].SetName(FUNCTION_STORAGE_VARIABLE3.m_Name);
self->m_Functions[3].SetReturnType(FUNCTION_STORAGE_VARIABLE3.m_ReturnType);
self->m_Functions[3].SetParameters(FUNCTION_STORAGE_VARIABLE3.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE3.m_Parameters.size());
self->m_Functions[3].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE3.m_InvokeFunc);
self->m_Functions[3].SetComment(FUNCTION_STORAGE_VARIABLE3.m_Comment);
self->m_Functions[3].SetReturnComment(FUNCTION_STORAGE_VARIABLE3.m_ReturnComment);
self->m_Functions[4].SetName(FUNCTION_STORAGE_VARIABLE4.m_Name);
self->m_Functions[4].SetReturnType(FUNCTION_STORAGE_VARIABLE4.m_ReturnType);
self->m_Functions[4].SetParameters(FUNCTION_STORAGE_VARIABLE4.m_Parameters.data(), FUNCTION_STORAGE_VARIABLE4.m_Parameters.size());
self->m_Functions[4].SetInvokeFuncPtr((std::function<void()>*)&FUNCTION_STORAGE_VARIABLE4.m_InvokeFunc);
self->m_Functions[4].SetComment(FUNCTION_STORAGE_VARIABLE4.m_Comment);
self->m_Functions[4].SetReturnComment(FUNCTION_STORAGE_VARIABLE4.m_ReturnComment);
self->m_Comment = "Me encantaria poder coger las estrellas con la mano";
static Category TestClass_class_attr0 = { "Test Class pero antes" };
self->m_Attributes.push_back(&TestClass_class_attr0);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
}
);

#define CLASS_DEFAULT_VALUE_VARIABLE TestClass_Heimdallr_Class_DefaultValue
#define CLASS_INFO_VARIABLE TestClass_Heimdallr_ClassInfo
#define CLASS_INFO_REGISTER_VARIABLE TestClass_Heimdallr_ClassInfo_Register
inline CLASS_TYPE CLASS_DEFAULT_VALUE_VARIABLE = {};
inline ClassInfo CLASS_INFO_VARIABLE
{
TypeInfo::InvalidID,
"TestClass",
"TestClass",
sizeof(CLASS_TYPE),
alignof(CLASS_TYPE),
&CLASS_DEFAULT_VALUE_VARIABLE,
CLASS_STORAGE_VARIABLE.m_ParentClasses.data(),
CLASS_STORAGE_VARIABLE.ParentClassesCount,
CLASS_STORAGE_VARIABLE.m_Fields.data(),
CLASS_STORAGE_VARIABLE.FieldsCount,
CLASS_STORAGE_VARIABLE.m_Functions.data(),
CLASS_STORAGE_VARIABLE.FunctionsCount,
CLASS_STORAGE_VARIABLE.m_Comment,
CLASS_STORAGE_VARIABLE.m_Attributes
};

inline hmdl::__internal__::registry::RegisterHelper CLASS_INFO_REGISTER_VARIABLE(&CLASS_INFO_VARIABLE);
} // anonymous namespace
template<> const TypeInfo* GetTypeImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return GetClass<CLASS_TYPE>();
}

template<> const ClassInfo* GetClassImpl(TemplatedTag<CLASS_TYPE>) noexcept
{
return &CLASS_INFO_VARIABLE;
}

} // __internal__
#undef CLASS_DEFAULT_VALUE_VARIABLE
#undef CLASS_STORAGE_VARIABLE
#undef CLASS_STORAGE_ARGS
#undef CLASS_INFO_VARIABLE
#undef CLASS_INFO_REGISTER_VARIABLE
} // namespace hmdl
#undef FUNCTION_STORAGE_VARIABLE0
#undef FUNCTION_STORAGE_VARIABLE1
#undef FUNCTION_STORAGE_VARIABLE2
#undef FUNCTION_STORAGE_VARIABLE3
#undef FUNCTION_STORAGE_VARIABLE4
#undef CLASS_TYPE
#undef CLASS_PARENT_CLASSES_COUNT
#undef CLASS_PROPERTIES_COUNT
#undef CLASS_FUNCTIONS_COUNT
#undef CLASS_TEMPLATED_ARGS_COUNT
#endif
#endif
// -------------------------------------------------------
// This code was auto-generated by Heimdallr. DO NOT EDIT!
// -------------------------------------------------------

#ifndef __GENERATE_HEIMDALLR_REFLECTION_ANNOTATION__
#pragma once
#ifndef _HEIMDALLR_ENUM_TestClass_MyCXXEnum_REFLECTED_GENERATED_
#define _HEIMDALLR_ENUM_TestClass_MyCXXEnum_REFLECTED_GENERATED_

#include "heimdallr.h"
#include "D:\gtada\Desktop\Repositorio_GitHUB\heimdallr\tools\..\Sandbox\src/Test.h"

#define ENUM_TYPE TestClass::MyCXXEnum
#define ENUM_COUNT 3
#define ENUM_DEFAULT_VALUE_VARIABLE TestClass_MyCXXEnum_Heimdallr_Enum_DefaultValue
#define ENUM_INFO_VARIABLE TestClass_MyCXXEnum_Heimdallr_EnumInfo
#define ENUM_INFO_REGISTER_VARIABLE TestClass_MyCXXEnum_Heimdallr_EnumInfo_Register
#define ENUM_STORAGE_VARIABLE TestClass_MyCXXEnum_Heimdallr_EnumStorage
namespace hmdl
{
namespace __internal__
{
namespace
{
inline EnumStorage<ENUM_TYPE, ENUM_COUNT> ENUM_STORAGE_VARIABLE(
[](EnumStorage<ENUM_TYPE, ENUM_COUNT>* self)
{
self->m_Values[0] = ENUM_TYPE::NONE;
self->m_Values[1] = ENUM_TYPE::NUNU;
self->m_Values[2] = ENUM_TYPE::NONO;
self->m_Strings[0] = "NONE";
self->m_Strings[1] = "NUNU";
self->m_Strings[2] = "NONO";
self->m_Comments[0] = "None de que no hace nada";
self->m_Comments[1] = "Nunu de que es mi amor";
self->m_Comments[2] = "Nono de que no quiero pero voy a hacerlo igual";
self->m_ValueToString[ENUM_TYPE::NONE] = "NONE";
self->m_ValueToString[ENUM_TYPE::NUNU] = "NUNU";
self->m_ValueToString[ENUM_TYPE::NONO] = "NONO";
self->m_StringToValue["NONE"] = ENUM_TYPE::NONE;
self->m_StringToValue["NUNU"] = ENUM_TYPE::NUNU;
self->m_StringToValue["NONO"] = ENUM_TYPE::NONO;
static std::function<const char* (ENUM_TYPE)> EnumToStringLambda = [self](ENUM_TYPE e) -> const char*
{
	return self->m_ValueToString[e];
};
self->m_EnumToStringFunc = EnumToStringLambda;
static std::function<ENUM_TYPE(const char*)> StringToEnumLambda = [self](const char* str) -> ENUM_TYPE
{
	return self->m_StringToValue[str];
};
self->m_StringToEnumFunc = StringToEnumLambda;
static std::function<const char* (void*)> EnumAddrToStringLambda = [](void* addr) -> const char*
{
	return EnumToStringLambda(*reinterpret_cast<ENUM_TYPE*>(addr));
};
self->m_ValueAddrToStringFunc = EnumAddrToStringLambda;
static std::function<bool(const char*)> StringEnumExistsLambda = [self](const char* str) -> bool
{
	return self->m_StringToValue.find(str) != self->m_StringToValue.end();
};
self->m_StringEnumExistsFunc = StringEnumExistsLambda;
static Category MyCXXEnum_enum_attr0 = { "Mi Categoria Enumerada" };
self->m_Attributes.push_back(&MyCXXEnum_enum_attr0);
static_assert(Category::CanAllowMultiple() || 1 == 1, "Cannot have multiple attributes of type Category");
self->m_Comment = "Comentario de un enum dentro de una clase TestClass";
});

inline ENUM_TYPE ENUM_DEFAULT_VALUE_VARIABLE = {};
inline EnumInfo ENUM_INFO_VARIABLE
{
TypeInfo::InvalidID,
"MyCXXEnum",
"TestClass::MyCXXEnum",
sizeof(ENUM_TYPE),
alignof(ENUM_TYPE),
&ENUM_DEFAULT_VALUE_VARIABLE,
ENUM_STORAGE_VARIABLE.m_Strings.data(),
ENUM_STORAGE_VARIABLE.m_Comments.data(),
ENUM_COUNT,
GetType<TestClass>(),
&ENUM_STORAGE_VARIABLE.m_ValueAddrToStringFunc,
&ENUM_STORAGE_VARIABLE.m_StringEnumExistsFunc,
reinterpret_cast<std::function<void()>*>(&ENUM_STORAGE_VARIABLE.m_EnumToStringFunc),
reinterpret_cast<std::function<void()>*>(&ENUM_STORAGE_VARIABLE.m_StringToEnumFunc),
ENUM_STORAGE_VARIABLE.m_Comment,
ENUM_STORAGE_VARIABLE.m_Attributes,
};

inline hmdl::__internal__::registry::RegisterHelper ENUM_INFO_REGISTER_VARIABLE(&ENUM_INFO_VARIABLE);
} // anonymous namespace
template<> const TypeInfo* GetTypeImpl(TemplatedTag<ENUM_TYPE>) noexcept
{
return GetEnum<ENUM_TYPE>();
}

template<> const EnumInfo* GetEnumImpl(TemplatedTag<ENUM_TYPE>) noexcept
{
return &ENUM_INFO_VARIABLE;
}

template<> const char* EnumToStringImpl(TemplatedTag<ENUM_TYPE>, ENUM_TYPE e) noexcept
{
return ENUM_STORAGE_VARIABLE.m_ValueToString[e];
}

template<> ENUM_TYPE StringToEnumImpl(TemplatedTag<ENUM_TYPE>, const char* str) noexcept
{
return ENUM_STORAGE_VARIABLE.m_StringToValue[str];
}

} // __internal__
template<> ENUM_TYPE* EnumRange<ENUM_TYPE>::begin() const { return ENUM_COUNT > 0 ? &__internal__::ENUM_STORAGE_VARIABLE.m_Values[0] : nullptr; };
template<> ENUM_TYPE* EnumRange<ENUM_TYPE>::end() const { return ENUM_COUNT > 0 ? &__internal__::ENUM_STORAGE_VARIABLE.m_Values[0] + ENUM_COUNT : nullptr; };

} // namespace hmdl
#undef ENUM_TYPE
#undef ENUM_COUNT
#undef ENUM_DEFAULT_VALUE_VARIABLE
#undef ENUM_INFO_VARIABLE
#undef ENUM_INFO_REGISTER_VARIABLE
#undef ENUM_STORAGE_VARIABLE
#endif
#endif
